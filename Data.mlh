I have tried to keep the mathematical content of the book to the minimum necessary
to achieve a proper understanding of the field. However, this minimum level is
nonzero, and it should be emphasized that a good grasp of calculus, linear algebra,
and probability theory is essential for a clear understanding of modern pattern recognition
and machine learning techniques. Nevertheless, the emphasis in this book is
on conveying the underlying concepts rather than on mathematical rigour.
I have tried to use a consistent notation throughout the book, although at times
this means departing from some of the conventions used in the corresponding research
literature. Vectors are denoted by lower case bold Roman letters such as
x, and all vectors are assumed to be column vectors. A superscript T denotes the
transpose of a matrix or vector, so that xT will be a row vector. Uppercase bold
roman letters, such as M, denote matrices. The notation (w1, . . . , wM) denotes a
row vector with M elements, while the corresponding column vector is written as
w = (w1, . . . , wM)T.
The notation [a, b] is used to denote the closed interval from a to b, that is the
interval including the values a and b themselves, while (a, b) denotes the corresponding
open interval, that is the interval excluding a and b. Similarly, [a, b) denotes an
interval that includes a but excludes b. For the most part, however, there will be
little need to dwell on such refinements as whether the end points of an interval are
included or not.
The M Ã— M identity matrix (also known as the unit matrix) is denoted IM,
which will be abbreviated to I where there is no ambiguity about it dimensionality.
It has elements Iij that equal 1 if i = j and 0 if i = j.
A functional is denoted f[y] where y(x) is some function. The concept of a
functional is discussed in Appendix D.
The notation g(x) = O(f(x)) denotes that |f(x)/g(x)| is bounded as x??.
For instance if g(x) = 3x2 + 2, then g(x) = O(x2).
The expectation of a function f(x, y) with respect to a random variable x is denoted
by Ex[f(x, y)]. In situations where there is no ambiguity as to which variable
is being averaged over, this will be simplified by omitting the suffix, for instance

also preserve useful discriminatory information enabling faces to be distinguished
from non-faces. These features are then used as the inputs to the pattern recognition
algorithm. For instance, the average value of the image intensity over a rectangular
subregion can be evaluated extremely efficiently (Viola and Jones, 2004), and a set of
such features can prove very effective in fast face detection. Because the number of
such features is smaller than the number of pixels, this kind of pre-processing represents
a form of dimensionality reduction. Care must be taken during pre-processing
because often information is discarded, and if this information is important to the
solution of the problem then the overall accuracy of the system can suffer.
Applications in which the training data comprises examples of the input vectors
along with their corresponding target vectors are known as supervised learning problems.
Cases such as the digit recognition example, in which the aim is to assign each
input vector to one of a finite number of discrete categories, are called classification
problems. If the desired output consists of one or more continuous variables, then
the task is called regression. An example of a regression problem would be the prediction
of the yield in a chemical manufacturing process in which the inputs consist
of the concentrations of reactants, the temperature, and the pressure.
In other pattern recognition problems, the training data consists of a set of input
vectors x without any corresponding target values. The goal in such unsupervised
learning problems may be to discover groups of similar examples within the data,
where it is called clustering, or to determine the distribution of data within the input
space, known as density estimation, or to project the data from a high-dimensional
space down to two or three dimensions for the purpose of visualization.
Finally, the technique of reinforcement learning (Sutton and Barto, 1998) is concerned
with the problem of finding suitable actions to take in a given situation in
order to maximize a reward. Here the learning algorithm is not given examples of
optimal outputs, in contrast to supervised learning, but must instead discover them
by a process of trial and error. Typically there is a sequence of states and actions in
which the learning algorithm is interacting with its environment. In many cases, the
current action not only affects the immediate reward but also has an impact on the reward
at all subsequent time steps. For example, by using appropriate reinforcement
learning techniques a neural network can learn to play the game of backgammon to a
high standard (Tesauro, 1994). Here the network must learn to take a board position
as input, along with the result of a dice throw, and produce a strong move as the
output. This is done by having the network play against a copy of itself for perhaps a
million games. A major challenge is that a game of backgammon can involve dozens
of moves, and yet it is only at the end of the game that the reward, in the form of
victory, is achieved. The reward must then be attributed appropriately to all of the
moves that led to it, even though some moves will have been good ones and others
less so. This is an example of a credit assignment problem. A general feature of reinforcement
learning is the trade-off between exploration, in which the system tries
out new kinds of actions to see how effective they are, and exploitation, in which
the system makes use of actions that are known to yield a high reward. Too strong
a focus on either exploration or exploitation will yield poor results. Reinforcement
learning continues to be an active area of machine learning research. However, a
